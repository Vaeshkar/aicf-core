/**
 * Enhanced AI Orchestrator with Phase Coordination
 * Fixes communication issues between AI phases
 */

import { AIOrchestrator } from './orchestrator.js';

export class EnhancedOrchestrator extends AIOrchestrator {
  constructor(providers = []) {
    super(providers);
    this.phaseResults = []; // Track all phase outputs
    this.projectContext = new Map(); // Track project state
    this.structureDecisions = []; // Track architectural decisions
  }

  /**
   * Enhanced phase execution with context sharing
   */
  async executePhase(phase, phaseIndex, allPhases) {
    console.log(`\n‚ö° Phase ${phaseIndex + 1}: ${phase.description}`);
    
    const phaseContext = this.buildPhaseContext(phase, phaseIndex, allPhases);\n    
    // Select AI with enhanced capability matching\n    const selectedAI = this.selectBestAI(phase.requiredCapabilities);\n    \n    // Create enhanced prompt with full context\n    const enhancedPrompt = this.createEnhancedPrompt(phase, phaseContext);\n    \n    console.log(`ü§ñ ${selectedAI.name} working on ${phase.type}...`);\n    \n    try {\n      const result = await selectedAI.sendMessage(phaseContext.contextString, enhancedPrompt);\n      \n      // Store phase result with metadata\n      const phaseResult = {\n        phase: phaseIndex + 1,\n        type: phase.type,\n        ai: selectedAI.name,\n        description: phase.description,\n        content: result.content,\n        tokens: result.tokens,\n        timestamp: new Date().toISOString(),\n        context: phaseContext\n      };\n      \n      this.phaseResults.push(phaseResult);\n      \n      // Update project context for next phases\n      this.updateProjectContext(phaseResult);\n      \n      return phaseResult;\n    } catch (error) {\n      console.error(`‚ùå Phase ${phaseIndex + 1} failed:`, error.message);\n      throw error;\n    }\n  }\n\n  /**\n   * Build comprehensive context for each phase\n   */\n  buildPhaseContext(currentPhase, phaseIndex, allPhases) {\n    const context = {\n      currentPhase: {\n        index: phaseIndex + 1,\n        type: currentPhase.type,\n        description: currentPhase.description,\n        requirements: currentPhase.requiredCapabilities\n      },\n      previousPhases: this.phaseResults.map(result => ({\n        phase: result.phase,\n        type: result.type,\n        ai: result.ai,\n        summary: this.summarizePhaseResult(result)\n      })),\n      remainingPhases: allPhases.slice(phaseIndex + 1).map((phase, idx) => ({\n        phase: phaseIndex + idx + 2,\n        type: phase.type,\n        description: phase.description\n      })),\n      projectStructure: this.getProjectStructure(),\n      createdFiles: Array.from(this.projectContext.keys()),\n      architecturalDecisions: this.structureDecisions\n    };\n\n    // Build context string for AI\n    context.contextString = this.buildContextString(context);\n    \n    return context;\n  }\n\n  /**\n   * Create enhanced prompt with project context\n   */\n  createEnhancedPrompt(phase, context) {\n    let prompt = `# AIOB Phase ${context.currentPhase.index}: ${phase.description}\\n\\n`;\n    \n    // Add role and responsibility\n    prompt += `## Your Role\\n`;\n    prompt += `You are the ${phase.type} specialist in a multi-AI team building a software project.\\n`;\n    prompt += `Required capabilities: ${phase.requiredCapabilities.join(', ')}\\n\\n`;\n    \n    // Add project context\n    if (context.previousPhases.length > 0) {\n      prompt += `## What Previous AIs Have Built\\n`;\n      context.previousPhases.forEach(prev => {\n        prompt += `- **Phase ${prev.phase} (${prev.ai}/${prev.type})**: ${prev.summary}\\n`;\n      });\n      prompt += `\\n`;\n    }\n    \n    // Add existing structure\n    if (context.createdFiles.length > 0) {\n      prompt += `## Existing Project Structure\\n`;\n      prompt += `The following files/directories already exist:\\n`;\n      context.createdFiles.forEach(file => {\n        prompt += `- ${file}\\n`;\n      });\n      prompt += `\\n**IMPORTANT**: Do NOT recreate these files. Build on the existing structure.\\n\\n`;\n    }\n    \n    // Add architectural decisions\n    if (context.architecturalDecisions.length > 0) {\n      prompt += `## Architectural Decisions Made\\n`;\n      context.architecturalDecisions.forEach(decision => {\n        prompt += `- ${decision}\\n`;\n      });\n      prompt += `\\n`;\n    }\n    \n    // Add remaining work\n    if (context.remainingPhases.length > 0) {\n      prompt += `## Upcoming Phases (for context)\\n`;\n      context.remainingPhases.forEach(upcoming => {\n        prompt += `- **Phase ${upcoming.phase}**: ${upcoming.description}\\n`;\n      });\n      prompt += `\\n`;\n    }\n    \n    // Add specific instructions\n    prompt += `## Your Specific Task\\n`;\n    prompt += this.getPhaseSpecificInstructions(phase);\n    \n    return prompt;\n  }\n\n  /**\n   * Get phase-specific instructions\n   */\n  getPhaseSpecificInstructions(phase) {\n    const instructions = {\n      'infrastructure': `\nCreate the foundational project structure and dependencies.\n- Set up package.json with correct dependencies\n- Create directory structure (but don't duplicate existing)\n- Configure build tools and development environment\n- Output complete, functional files with no placeholders\n\nFORMAT: Use CREATE_FILE: syntax for each file:\nCREATE_FILE: path/to/file.ext\n[complete file content here]\n`,\n      \n      'backend': `\nImplement the complete backend API with all endpoints.\n- Create Express server with all required middleware\n- Implement ALL CRUD operations (don't leave TODOs)\n- Add proper error handling and validation\n- Ensure data persistence works correctly\n- Test that endpoints return correct JSON responses\n\nFORMAT: Use CREATE_FILE: syntax for each file:\nCREATE_FILE: path/to/file.ext\n[complete file content here]\n`,\n      \n      'frontend': `\nCreate the complete user interface with all functionality.\n- Build React components that actually work\n- Connect to backend API endpoints\n- Implement all user interactions (add, edit, delete, toggle)\n- Style with Tailwind CSS for modern appearance\n- Handle loading states and error conditions\n- Make it responsive for mobile/desktop\n\nFORMAT: Use CREATE_FILE: syntax for each file:\nCREATE_FILE: path/to/file.ext\n[complete file content here]\n`,\n      \n      'qa': `\nValidate and test the complete application.\n- Verify all API endpoints work correctly\n- Check that frontend connects to backend\n- Test user workflows end-to-end\n- Identify and fix any integration issues\n- Create test files if needed\n- Provide deployment instructions\n\nFORMAT: Use CREATE_FILE: syntax for any additional files:\nCREATE_FILE: path/to/file.ext\n[complete file content here]\n`\n    };\n    \n    return instructions[phase.type] || `Complete the ${phase.type} phase with working, production-ready code.`;\n  }\n\n  /**\n   * Build context string for AI consumption\n   */\n  buildContextString(context) {\n    let contextStr = `Project: Multi-phase software development\\n`;\n    contextStr += `Current Phase: ${context.currentPhase.index} of ${context.currentPhase.index + context.remainingPhases.length}\\n`;\n    \n    if (context.previousPhases.length > 0) {\n      contextStr += `\\nPrevious Work Completed:\\n`;\n      context.previousPhases.forEach(phase => {\n        contextStr += `- Phase ${phase.phase}: ${phase.summary}\\n`;\n      });\n    }\n    \n    return contextStr;\n  }\n\n  /**\n   * Summarize phase result for next phases\n   */\n  summarizePhaseResult(result) {\n    // Extract key information from the result\n    const lines = result.content.split('\\n');\n    const fileCreated = lines.filter(line => line.includes('CREATE_FILE:')).length;\n    \n    let summary = `${result.description}`;\n    if (fileCreated > 0) {\n      summary += ` (created ${fileCreated} files)`;\n    }\n    \n    return summary;\n  }\n\n  /**\n   * Update project context after each phase\n   */\n  updateProjectContext(phaseResult) {\n    // Extract file creations from the result\n    const fileMatches = phaseResult.content.match(/CREATE_FILE:\\s*([^\\n]+)/g);\n    if (fileMatches) {\n      fileMatches.forEach(match => {\n        const filePath = match.replace('CREATE_FILE:', '').trim();\n        this.projectContext.set(filePath, {\n          createdBy: phaseResult.ai,\n          phase: phaseResult.phase,\n          timestamp: phaseResult.timestamp\n        });\n      });\n    }\n    \n    // Track architectural decisions\n    if (phaseResult.type === 'infrastructure') {\n      this.structureDecisions.push(`Project structure defined by ${phaseResult.ai}`);\n    }\n  }\n\n  /**\n   * Get current project structure\n   */\n  getProjectStructure() {\n    const structure = {};\n    for (const [filePath] of this.projectContext) {\n      const parts = filePath.split('/');\n      let current = structure;\n      \n      for (let i = 0; i < parts.length - 1; i++) {\n        if (!current[parts[i]]) {\n          current[parts[i]] = {};\n        }\n        current = current[parts[i]];\n      }\n      \n      if (parts.length > 0) {\n        current[parts[parts.length - 1]] = 'file';\n      }\n    }\n    \n    return structure;\n  }\n\n  /**\n   * Enhanced build verification\n   */\n  async verifyBuild(projectDir) {\n    console.log('\\nüß™ Verifying build...');\n    \n    const checks = [\n      this.checkPackageJson(projectDir),\n      this.checkServerFile(projectDir),\n      this.checkFrontendFiles(projectDir)\n    ];\n    \n    const results = await Promise.allSettled(checks);\n    \n    let passed = 0;\n    let failed = 0;\n    \n    results.forEach((result, index) => {\n      if (result.status === 'fulfilled' && result.value) {\n        passed++;\n        console.log(`‚úÖ Check ${index + 1} passed`);\n      } else {\n        failed++;\n        console.log(`‚ùå Check ${index + 1} failed:`, result.reason || 'Unknown error');\n      }\n    });\n    \n    console.log(`\\nüìä Build verification: ${passed} passed, ${failed} failed`);\n    return failed === 0;\n  }\n\n  async checkPackageJson(projectDir) {\n    // Implementation for checking package.json validity\n    return true; // Placeholder\n  }\n\n  async checkServerFile(projectDir) {\n    // Implementation for checking server file exists and is valid\n    return true; // Placeholder\n  }\n\n  async checkFrontendFiles(projectDir) {\n    // Implementation for checking frontend files exist\n    return true; // Placeholder\n  }\n}